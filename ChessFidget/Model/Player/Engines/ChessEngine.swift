//
//  ChessEngine.swift
//  ChessFidget
//
//  Created by Andy Lee on 9/13/17.
//  Copyright Â© 2017 Andy Lee. All rights reserved.
//

import Foundation

/// Represents "the computer" in a human-vs.-computer chess game.  Moves are
/// generated by the Sjeng chess engine that comes installed on every Mac.
class ChessEngine: EnginePlayer, ProcessWrapperDelegate {
	/// Used for launching a Sjeng process and exchanging data with it.
	private var processWrapper: ProcessWrapper

	// MARK: - Init/deinit

	required init() {
		// Initialize properties.
		let oldChessEnginePath = "/Applications/Chess.app/Contents/Resources/sjeng.ChessEngine"
		let chessEnginePath = (FileManager.default.fileExists(atPath: oldChessEnginePath)
							   ? oldChessEnginePath
							   : "/System/" + oldChessEnginePath)
		self.processWrapper = ProcessWrapper(launchPath: chessEnginePath, arguments: [])

		// Call a designated initializer in super.
		super.init(name: "Sjeng Engine")

		// Launch the engine and send initial commands.
		processWrapper.delegate = self
		processWrapper.launchProcess()
//		sendCommandToEngine("sd 4")  // Limit search depth.
		sendCommandToEngine("sd 1")  // Limit search depth.
		sendCommandToEngine("st 1")  // Limit search time.
		sendCommandToEngine("easy")  // Only search for moves while it is the computer's turn.
	}

	// MARK: - Player methods

	override func beginTurn() {
		startMoveForcingTimer()
		if let move = owningGame?.moveHistory.last {
			sendCommandToEngine(move.algebraicString)
		} else {
			sendCommandToEngine("go")
		}
	}

	// MARK: - ProcessWrapperDelegate protocol

	func didReadFromStdout(_ processWrapper: ProcessWrapper, data: Data) {
		//printReceivedData(data)  // This is handy to uncomment when debugging.

		guard data.count > 0 else { return }
		guard let s = stringFromData(data) else { return }

		// Split the input into lines.  If we see a line that parses as a valid
		// move by the computer, play that move on the computer's behalf.
		//
		// TODO: Should theoretically handle the case where the output from the
		// computer is fragmented across multiple calls to this method, as
		// sometimes happens with the ASCII board representation (which we
		// ignore).  I'm assuming that won't happen with moves, which are always
		// very short strings.
		let lines = s.components(separatedBy: "\n")
		for line in lines {
			if let move = owningGame?.position.moveFromAlgebraicString(line, reportErrors: false) {
				stopMoveForcingTimer()
				print(";;; Received from engine: [\(line)]")
				owningGame?.applyMove(move)
			}
		}
	}

	func didReadFromStderr(_ processWrapper: ProcessWrapper, data: Data) {
		printReceivedData(data)
	}

	func didTerminate(_ processWrapper: ProcessWrapper) {
		print(self, "process did terminate")
	}

	// MARK: - Private methods

	private func stringFromData(_ data: Data) -> String? {
		return String(data: data, encoding: String.Encoding.utf8)
	}

	private func printReceivedData(_ data: Data) {
		guard data.count > 0 else {
			return
		}
		if let stringFromData = stringFromData(data) {
			print(stringFromData, terminator: "")
		} else {
			print(";;; [WARNING] Could not convert received data to string.")
		}
	}

	private func sendCommandToEngine(_ command: String) {
		assert(processWrapper.isRunning,
		       "The chess engine is not running. Can't send a command to it.")
		print(";;; sending [\(command)] to the chess engine")
		// Make sure there's a terminating newline.  Easy to forget, then wonder
		// why the engine isn't responding.
		var loweredString = command.lowercased()
		if command.last != "\n" {
			loweredString += "\n"
		}
		processWrapper.writeToProcess(loweredString)
	}
	
	// MARK: - Move timer
	
	/// Workaround for the fact that the `st` command no longer seems to work with Sjeng.
	private var moveForcingTimer: Timer?
	
	private func startMoveForcingTimer() {
		if moveForcingTimer != nil { return }
		
		// Sometimes we send "stop" and never get a move from the engine.  It doesn't
		// feel like repeating the timer is the right solution -- this is a stopgap.
		moveForcingTimer = Timer.scheduledTimer(withTimeInterval: 0.1, repeats: true) { [weak self] _ in
			if case .awaitingMove = self?.owningGame?.gameState {
				print(";;; Move timer triggered")
				self?.sendCommandToEngine("stop")
			}
		}
	}
	
	private func stopMoveForcingTimer() {
		moveForcingTimer?.invalidate()
		moveForcingTimer = nil
	}
}

