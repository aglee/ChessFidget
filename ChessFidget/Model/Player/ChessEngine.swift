//
//  ChessEngine.swift
//  ChessFidget
//
//  Created by Andy Lee on 9/13/17.
//  Copyright Â© 2017 Andy Lee. All rights reserved.
//

import Foundation

/// Represents "the computer" in a human-vs.-computer chess game.  Moves are
/// generated by the Sjeng chess engine that comes installed on every Mac.
class ChessEngine: Player, ProcessWrapperDelegate {
	override var isHuman: Bool { return false }

	/// Used for launching a Sjeng process and exchanging data with it.
	private var processWrapper: ProcessWrapper

	// MARK: - Init/deinit

	init(makeFirstMove: Bool) {
		// Initialize properties.
		let oldChessEnginePath = "/Applications/Chess.app/Contents/Resources/sjeng.ChessEngine"
		let chessEnginePath = (FileManager.default.fileExists(atPath: oldChessEnginePath)
							   ? oldChessEnginePath
							   : "/System/" + oldChessEnginePath)
		self.processWrapper = ProcessWrapper(launchPath: chessEnginePath, arguments: [])

		// Call a designated initializer in super.
		super.init(name: "Computer")

		// Launch the engine and send initial commands.
		self.processWrapper.delegate = self
		self.processWrapper.launchProcess()
		self.sendCommandToEngine("sd 4")  // Limit search depth.
		self.sendCommandToEngine("st 1")  // Limit search time.
		self.sendCommandToEngine("easy")  // Only search for moves while it is the computer's turn.
		if makeFirstMove {
			self.sendCommandToEngine("go")
		}
	}

	// MARK: - Player methods

	override func opponentDidMove(_ move: Move) {
		self.sendCommandToEngine(move.algebraicString)
	}

	// MARK: - ProcessWrapperDelegate protocol

	func didReadFromStdout(_ processWrapper: ProcessWrapper, data: Data) {
		//self.printReceivedData(data)  // This is handy to uncomment when debugging.

		guard data.count > 0 else { return }
		guard let s = stringFromData(data) else { return }

		// Split the input into lines.  If we see a line that parses as a valid
		// move by the computer, play that move on the computer's behalf.
		//
		// TODO: Should theoretically handle the case where the output from the
		// computer is fragmented across multiple calls to this method, as
		// sometimes happens with the ASCII board representation (which we
		// ignore).  I'm assuming that won't happen with moves, which are always
		// very short strings.
		let lines = s.components(separatedBy: "\n")
		for line in lines {
			if let move = self.owningGame?.position.moveFromAlgebraicString(line, reportErrors: false) {
				self.owningGame?.applyGeneratedMove(move)
			}
		}
	}

	func didReadFromStderr(_ processWrapper: ProcessWrapper, data: Data) {
		self.printReceivedData(data)
	}

	func didTerminate(_ processWrapper: ProcessWrapper) {
		print(self, "process did terminate")
	}

	// MARK: - Private methods

	private func stringFromData(_ data: Data) -> String? {
		return String(data: data, encoding: String.Encoding.utf8)
	}

	private func printReceivedData(_ data: Data) {
		guard data.count > 0 else {
			return
		}
		if let stringFromData = stringFromData(data) {
			print(stringFromData, terminator: "")
		} else {
			print("+++ [WARNING] Could not convert received data to string.")
		}
	}

	private func sendCommandToEngine(_ command: String) {
		assert(self.processWrapper.isRunning,
		       "The chess engine is not running. Can't send a command to it.")
		print("+++ sending [\(command)] to the chess engine")
		// Make sure there's a terminating newline.  Easy to forget, then wonder
		// why the engine isn't responding.
		var loweredString = command.lowercased()
		if command.characters.last != "\n" {
			loweredString += "\n"
		}
		self.processWrapper.writeToProcess(loweredString)
	}
}

