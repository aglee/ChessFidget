//
//  Game.swift
//  ChessFidget
//
//  Created by Andy Lee on 8/25/16.
//  Copyright Â© 2016 Andy Lee. All rights reserved.
//

import Foundation

/// Represents a chess game between a human player (the user) and the computer.
/// The computer's moves are either randomly selected or generated by a backend
/// engine.
class Game {
	var position: Position = Position()
	var humanPlayerPieceColor: PieceColor
	var computerPlaysRandomly: Bool
	var gameState: GameState = .awaitingStart {
		didSet {
			gameObserver?.gameDidChangeState(self, oldValue: oldValue)
			print("+++ game state transition: \(oldValue) => \(gameState)")
		}
	}
	var chessEngine: ChessEngine?
	var gameObserver: GameObserver?

	// MARK: - Init/deinit

	init(humanPlays pieceColor: PieceColor, computerPlaysRandomly: Bool) {
		self.humanPlayerPieceColor = pieceColor
		self.computerPlaysRandomly = computerPlaysRandomly
	}

	// MARK: - Game play

	func startPlay() {
		assertExpectedGameState(.awaitingStart)
		if !self.computerPlaysRandomly {
			let computerMovesFirst = (self.humanPlayerPieceColor == .black)
			self.chessEngine = ChessEngine(game: self,
			                               makeFirstMove: computerMovesFirst)
		}
		awaitTheNextMove()
	}

	private func moveStringForEngine(_ move: Move) -> String {
		let startAndEndSquares = "\(move.start.squareName)\(move.end.squareName)"
		if case .pawnPromotion(let promoType) = move.type {
			switch promoType {
			case .promoteToBishop: return startAndEndSquares + "b"
			case .promoteToKnight: return startAndEndSquares + "n"
			case .promoteToRook: return startAndEndSquares + "r"
			case .promoteToQueen: return startAndEndSquares + "q"
			}
		} else {
			return startAndEndSquares
		}
	}

	func makeHumanMove(_ move: Move) {
		makeMove(move)
		chessEngine?.sendEngineHumanMove(moveStringForEngine(move))
	}

	func engineDidApproveHumanMove(_ moveString: String) {
		print("+++ \(type(of: self)).\(#function) -- \(moveString)")
	}

	func engineDidSendComputerMove(_ moveString: String) {
		print("+++ \(type(of: self)).\(#function) -- \(moveString)")

		guard let move = moveFromEngineString(moveString, reportErrors: true) else {
			print("ERROR: Couldn't create a Move from the string '\(moveString)'.")
			return
		}

		DispatchQueue.main.async {
			print("+++ about to make computer's move \(move.debugString)")
			self.makeMove(move)
		}
	}

	func assertExpectedGameState(_ expectedGameState: GameState) {
		assert("\(gameState)" == "\(expectedGameState)", "Expected game state to be '\(expectedGameState)'.")
	}

	// Converts a string like "e2e4" into a Move instance.
	func moveFromEngineString(_ engineString: String,
	                                  reportErrors: Bool) -> Move? {
		var str = engineString.lowercased() as NSString
		if str.hasSuffix("\n") {
			str = str.substring(to: str.length - 1) as NSString
		}

		guard str.length == 4 || str.length == 5 else {
			if reportErrors {
				print("ERROR: Engine string '\(str)' has unexpected length.")
			}
			return nil
		}

		guard let startPoint = GridPointXY(algebraic: str.substring(with: NSMakeRange(0, 2))) else {
			if reportErrors {
				print("ERROR: Engine string '\(str)' has invalid start square.")
			}
			return nil
		}

		guard let endPoint = GridPointXY(algebraic: str.substring(with: NSMakeRange(2, 2))) else {
			if reportErrors {
				print("ERROR: Engine string '\(str)' has invalid end square.")
			}
			return nil
		}

		let validity = MoveValidator(position: position, startPoint: startPoint, endPoint: endPoint).validateMove()
		switch validity {
		case .invalid(_):
			return nil
		case .valid(let moveType):
			if case .pawnPromotion(_) = moveType {
				assert(str.length == 5, "ERROR: Engine string '\(str)' represents a pawn promotion, but does not specify the piece to promote to.")
				let promoType: PromotionType
				switch str.substring(from: 4).lowercased() {
				case "b": promoType = .promoteToBishop
				case "n": promoType = .promoteToKnight
				case "r": promoType = .promoteToRook
				case "q": promoType = .promoteToQueen
				default:
					fatalError("Unexpected promotion type in move string '\(str)' received from the engine.")
				}
				return Move(from: startPoint, to: endPoint, type: .pawnPromotion(type: promoType))
			} else {
				return Move(from: startPoint, to: endPoint, type: moveType)
			}
		}
	}

	// MARK: - Private methods

	// Apply the move to the game, position, and board.  Assumes the given move is valid for the current position.
	private func makeMove(_ move: Move) {
		print("+++ \(move.debugString) (\(move.type)) played by \(position.whoseTurn.debugString) (\(position.whoseTurn == humanPlayerPieceColor ? "Human" : "Computer"))")

		position.makeMove(move)
		gameObserver?.gameDidMakeMove(self, move: move)

		awaitTheNextMove()
	}

	private func seeIfGameIsAutomaticallyOver() -> ReasonGameIsOver? {
		if position.validMoves.count > 0 {
			return nil
		}

		if position.board.isInCheck(position.whoseTurn) {
			switch position.whoseTurn {
			case .black: return .whiteWinsByCheckmate
			case .white: return .blackWinsByCheckmate
			}
		}

		return .drawDueToStalemate
	}

	// This is called when the game starts and after each move by either player.
	// It performs the appropriate state transition.
	private func awaitTheNextMove() {
		if let reason = seeIfGameIsAutomaticallyOver() {
			// The last move caused the game to be over.
			print("+++ game is over -- \(reason)")
			gameState = .gameIsOver(reason: reason)
		} else if humanPlayerPieceColor == position.whoseTurn {
			// It's the human's turn.  Nothing further to do except wait for
			// them to interact with the UI.
			gameState = .awaitingHumanMove
		} else {
			// It's the computer's turn.  If we aren't using AI, select a random
			// valid move and have the computer make it.  If we *are* using AI,
			// there is nothing further to do -- the chess engine is already
			// "thinking" and we will get notified when it tells us its move.
			gameState = .awaitingComputerMove

			if computerPlaysRandomly {
				let validMoves = position.validMoves
				let delay = 0.1
				let when = DispatchTime.now() + delay  //[agl] Why did I add a delay?
				DispatchQueue.main.asyncAfter(deadline: when, execute: {
					let moveIndex = Int(arc4random_uniform(UInt32(validMoves.count)))
					self.makeMove(validMoves[moveIndex])
				})
			}
		}
	}
}

